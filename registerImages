#!/usr/bin/python

import os
import argparse
from pythonMods import jsonTools, parallelization
import subprocess as sp


def create_parser():
    parser = argparse.ArgumentParser(
        description="A script to register images to the Allen Brain Atlas using ITK.")
    parser.add_argument('-e', '--experimentPath', default=os.getcwd())
    parser.add_argument('-b', '--useBatch', action='store_true')
    parser.add_argument('-n', '--maxThreads', default=float('inf'))
    parser.add_argument('-a', '--refAtlasPath',
                        default=os.path.expanduser('~/code/fishRegistration/atlasVolume/atlasVolume.mhd'))
    parser.add_argument('-h', '--hemiAtlasPath',
                        default=os.path.expanduser('~/code/fishRegistration/atlasVolume/hemisphereMask.mhd'))
    parser.add_argument('-l', '--annoAtlasPath',
                        default=os.path.expanduser('~/code/fishRegistration/atlasVolume/annotation.mhd'))
    return parser


def create_arg_list(im_data, args):
    arg_str = "registerSliceToAtlas '{downsampledImagePath}' '{atlasIndex}'" \
        "'{registeredAtlasReferenceImagePath}' '{registeredAtlasLabelsPath}' " \
        "'{registeredHemisphereLabelsPath}' '{registrationMetricLogPath}' ".format(**im_data) + \
        "'{refAtlasPath}' '{annoAtlasPath}' '{hemiAtlasPath}' ".format(**args)
    return arg_str.split()


def create_output_paths(im_data):
    im_data['registeredAtlasReferenceImagePath'] = compose_output_path(im_data, u'_registeredAtlasReferenceImage.mhd')
    im_data['registeredAtlasLabelsPath'] = compose_output_path(im_data, u'_registeredAtlasLabels.mhd')
    im_data['registrationMetricLogPath'] = compose_output_path(im_data, u'_registrationMetricLog.tsv')
    im_data['registeredHemisphereLabelsPath'] = compose_output_path(im_data, u'_registeredHemisphereLabels.mhd')


def compose_output_path(im_data, suffix):
    # removes '_downsampled' from the downsampled image path and appends a suffix
    return im_data['downsampledImagePath'].rsplit('_', 1)[0] + suffix


def create_exit_callback(im_data, handler):
    def callback(result):
        # TODO: Check result
        im_data['registrationSuccessful'] = True
        handler.update_metadata()
    return callback


def create_output_callback(im_data):
    f = im_data['registrationOutputLogPath'].open()
    def callback(data):


def create_registration_process(im_data, args):
    arg_list = create_arg_list(im_data, args)
    im_data['registrationOutputLogPath'] = compose_output_path(im_data, u'_registrationOutputLog')
    output_callback = create_output_callback(im_data)
    if args.useBatch:
        return parallelization.BatchProcess(*arg_list)
    else:
        return parallelization.Process('registerSliceToAtlas', *arg_list)


def main():
    parser = create_parser()
    args = parser.parse_args()
    exp_path = args.experimentPath

    # Load JSON
    metadata_handler = jsonTools.MetadataHandler(experiment_path=exp_path)
    metadata = metadata_handler.load_metadata()

    # Create and configure the process scheduler
    scheduler = parallelization.Scheduler(max_threads=args.maxThreads)

    for im_data in metadata:
        if not im_data['exclude']:
            create_output_paths(im_data)
                process = create_registration_process(im_data, args)
                exit_callback = create_exit_callback(im_data, metadata_handler)

        else:
            print "Excluding " + im_data['vsiPath']

    print 'Registering Images.  This may take a while.....'

    scheduler.run_processes()

    print 'Registration Complete!'

if __name__ == '__main__':
    main()
